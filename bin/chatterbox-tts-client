#!/usr/bin/env python3
"""
Chatterbox TTS Client for Speech Dispatcher

This client connects to the Chatterbox TTS daemon and requests synthesis.
It's designed to be called by speech-dispatcher's generic module.

Usage:
    echo "Text to speak" | chatterbox-tts-client [options]
    chatterbox-tts-client --text "Text to speak" [options]
"""

import argparse
import json
import os
import socket
import struct
import subprocess
import sys
import time

RUNTIME_DIR = os.environ.get("XDG_RUNTIME_DIR", "/tmp")
CPU_SOCKET_PATH = os.path.join(RUNTIME_DIR, "chatterbox-tts/chatterbox-tts.sock")
CUDA_SOCKET_PATH = os.path.join(RUNTIME_DIR, "chatterbox-tts-cuda/chatterbox-tts.sock")
CONNECT_TIMEOUT = 30
READ_TIMEOUT = 120


def has_nvidia_gpu() -> bool:
    """Check if an NVIDIA GPU is available on the system."""
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name", "--format=csv,noheader"],
            capture_output=True,
            timeout=10  # Allow time for driver initialization on first call
        )
        return result.returncode == 0 and bool(result.stdout.strip())
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return False


def get_socket_path(prefer_gpu: bool | None = None) -> str:
    """
    Determine which socket to use based on GPU availability.

    Args:
        prefer_gpu: True to prefer GPU, False to prefer CPU, None for auto-detect

    Returns:
        Path to the appropriate socket
    """
    # Check environment variable override
    env_socket = os.environ.get("CHATTERBOX_SOCKET")
    if env_socket:
        return env_socket

    # Check preference
    env_prefer = os.environ.get("CHATTERBOX_PREFER_GPU", "").lower()
    if prefer_gpu is None:
        if env_prefer in ("1", "true", "yes"):
            prefer_gpu = True
        elif env_prefer in ("0", "false", "no"):
            prefer_gpu = False

    # Auto-detect: try CUDA socket if GPU available, otherwise CPU
    if prefer_gpu is True:
        # User wants GPU - try CUDA first, fall back to CPU
        if os.path.exists(CUDA_SOCKET_PATH):
            return CUDA_SOCKET_PATH
        return CPU_SOCKET_PATH
    elif prefer_gpu is False:
        # User wants CPU
        return CPU_SOCKET_PATH
    else:
        # Auto-detect: prefer CUDA if GPU available and socket exists
        if has_nvidia_gpu() and os.path.exists(CUDA_SOCKET_PATH):
            return CUDA_SOCKET_PATH
        if os.path.exists(CPU_SOCKET_PATH):
            return CPU_SOCKET_PATH
        # Neither exists yet - prefer CUDA if GPU available (socket activation will start it)
        if has_nvidia_gpu():
            return CUDA_SOCKET_PATH
        return CPU_SOCKET_PATH


def send_request(sock: socket.socket, request: dict) -> dict:
    """Send a request and receive response."""
    data = json.dumps(request).encode("utf-8")
    length = struct.pack(">I", len(data))
    sock.sendall(length + data)

    # Read response length
    length_data = sock.recv(4)
    if len(length_data) < 4:
        raise RuntimeError("Connection closed by server")

    msg_length = struct.unpack(">I", length_data)[0]

    # Read response
    data = b""
    while len(data) < msg_length:
        chunk = sock.recv(min(4096, msg_length - len(data)))
        if not chunk:
            break
        data += chunk

    return json.loads(data.decode("utf-8"))


def connect_to_daemon(socket_path: str, max_retries: int = 3) -> socket.socket:
    """Connect to the daemon, with retries."""
    last_error = None

    for attempt in range(max_retries):
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.settimeout(CONNECT_TIMEOUT)
            sock.connect(socket_path)
            return sock
        except OSError as e:
            last_error = e
            if attempt < max_retries - 1:
                time.sleep(0.5)

    raise RuntimeError(f"Failed to connect to daemon at {socket_path}: {last_error}")


def play_audio(audio_file: str, player: str = "auto"):
    """Play audio file using the specified player."""
    players = {
        "aplay": ["aplay", "-q", audio_file],
        "paplay": ["paplay", audio_file],
        "pw-play": ["pw-play", audio_file],
        "play": ["play", "-q", audio_file],  # sox
        "mpv": ["mpv", "--no-terminal", "--no-video", audio_file],
        "ffplay": ["ffplay", "-nodisp", "-autoexit", "-loglevel", "quiet", audio_file],
    }

    if player == "auto":
        # Try players in order of preference
        for name, cmd in players.items():
            try:
                # Check if player exists
                subprocess.run(["which", cmd[0]], capture_output=True, check=True)
                player = name
                break
            except subprocess.CalledProcessError:
                continue
        else:
            raise RuntimeError("No suitable audio player found. Install aplay, paplay, or mpv.")

    if player not in players:
        # Custom player command
        cmd = [player, audio_file]
    else:
        cmd = players[player]

    subprocess.run(cmd, check=True)


def main():
    parser = argparse.ArgumentParser(
        description="Chatterbox TTS Client for Speech Dispatcher"
    )
    parser.add_argument(
        "--socket", "-s",
        default=None,
        help="Path to daemon Unix socket (default: auto-detect based on GPU)"
    )
    parser.add_argument(
        "--prefer-gpu",
        action="store_true",
        default=None,
        help="Prefer CUDA/GPU backend if available"
    )
    parser.add_argument(
        "--prefer-cpu",
        action="store_true",
        help="Prefer CPU backend even if GPU is available"
    )
    parser.add_argument(
        "--text", "-t",
        default=None,
        help="Text to synthesize (default: read from stdin)"
    )
    parser.add_argument(
        "--voice", "-v",
        default=os.environ.get("CHATTERBOX_VOICE", "default"),
        help="Voice to use (default: default)"
    )
    parser.add_argument(
        "--exaggeration", "-e",
        type=float,
        default=float(os.environ.get("CHATTERBOX_EXAGGERATION", "0.5")),
        help="Exaggeration parameter 0.0-1.0 (default: 0.5)"
    )
    parser.add_argument(
        "--cfg-weight", "-c",
        type=float,
        default=float(os.environ.get("CHATTERBOX_CFG_WEIGHT", "0.5")),
        help="CFG weight parameter 0.0-1.0 (default: 0.5)"
    )
    parser.add_argument(
        "--player", "-p",
        default=os.environ.get("CHATTERBOX_PLAYER", "auto"),
        help="Audio player to use (auto, aplay, paplay, pw-play, play, mpv, ffplay)"
    )
    parser.add_argument(
        "--output", "-o",
        default=None,
        help="Save audio to file instead of playing"
    )
    parser.add_argument(
        "--no-play",
        action="store_true",
        help="Don't play audio, just output the file path"
    )
    parser.add_argument(
        "--list-voices",
        action="store_true",
        help="List available voices and exit"
    )
    parser.add_argument(
        "--ping",
        action="store_true",
        help="Check if daemon is running"
    )

    args = parser.parse_args()

    # Determine socket path
    if args.socket:
        socket_path = args.socket
    else:
        # Determine GPU preference
        if args.prefer_cpu:
            prefer_gpu = False
        elif args.prefer_gpu:
            prefer_gpu = True
        else:
            prefer_gpu = None  # Auto-detect
        socket_path = get_socket_path(prefer_gpu)

    try:
        sock = connect_to_daemon(socket_path)
    except RuntimeError as e:
        print(f"Error: {e}", file=sys.stderr)
        print("Is the chatterbox-tts service running?", file=sys.stderr)
        print("Try: systemctl --user start chatterbox-tts.socket", file=sys.stderr)
        sys.exit(1)

    try:
        sock.settimeout(READ_TIMEOUT)

        if args.ping:
            response = send_request(sock, {"command": "ping"})
            if response.get("status") == "ok":
                print("Daemon is running")
                sys.exit(0)
            else:
                print(f"Unexpected response: {response}")
                sys.exit(1)

        if args.list_voices:
            response = send_request(sock, {"command": "list_voices"})
            if response.get("status") == "ok":
                print("Available voices:")
                for voice in response.get("voices", []):
                    print(f"  {voice}")
                sys.exit(0)
            else:
                print(f"Error: {response.get('error', 'Unknown error')}", file=sys.stderr)
                sys.exit(1)

        # Get text to synthesize
        if args.text:
            text = args.text
        else:
            text = sys.stdin.read()

        text = text.strip()
        if not text:
            print("Error: No text provided", file=sys.stderr)
            sys.exit(1)

        # Normalize voice name (handle speech-dispatcher's "no_voice" or empty values)
        voice = args.voice
        if not voice or voice in ("no_voice", ""):
            voice = "default"

        # Send synthesis request
        request = {
            "command": "synthesize",
            "text": text,
            "voice": voice,
            "exaggeration": args.exaggeration,
            "cfg_weight": args.cfg_weight
        }

        response = send_request(sock, request)

        if response.get("error"):
            print(f"Error: {response['error']}", file=sys.stderr)
            sys.exit(1)

        audio_file = response.get("audio_file")
        if not audio_file:
            print("Error: No audio file in response", file=sys.stderr)
            sys.exit(1)

        # Translate container path to host path
        # Container: /app/output/file.wav -> Host: $XDG_RUNTIME_DIR/chatterbox-tts[/-cuda]/file.wav
        container_prefix = "/app/output/"
        if audio_file.startswith(container_prefix):
            host_socket_dir = os.path.dirname(socket_path)
            audio_file = os.path.join(host_socket_dir, audio_file[len(container_prefix):])

        if args.output:
            # Copy to output file
            import shutil
            shutil.copy(audio_file, args.output)
            os.remove(audio_file)
            print(args.output)
        elif args.no_play:
            print(audio_file)
        else:
            # Play the audio
            try:
                play_audio(audio_file, args.player)
            finally:
                # Clean up temp file
                try:
                    os.remove(audio_file)
                except OSError:
                    pass

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    finally:
        sock.close()


if __name__ == "__main__":
    main()
