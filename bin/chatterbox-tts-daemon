#!/usr/bin/env python3
"""
Chatterbox TTS Daemon for Speech Dispatcher

This daemon loads the Chatterbox TTS model once and listens on a Unix socket
for synthesis requests. This avoids the overhead of loading the model for
each utterance.

Models are downloaded automatically on first use from Hugging Face.
"""

import argparse
import json
import os
import signal
import socket
import struct
import sys
import tempfile
import threading
import time

# Ensure we can find the modules
try:
    import torch
    import torchaudio as ta
except ImportError:
    print("Error: PyTorch and torchaudio are required.", file=sys.stderr)
    print("Install with: pip install torch torchaudio", file=sys.stderr)
    sys.exit(1)

try:
    from chatterbox.tts_turbo import ChatterboxTurboTTS
except ImportError:
    print("Error: chatterbox-tts is required.", file=sys.stderr)
    print("Install with: pip install chatterbox-tts", file=sys.stderr)
    sys.exit(1)

# Configuration
DEFAULT_SOCKET_PATH = "/tmp/chatterbox-tts.sock"
DEFAULT_CACHE_DIR = os.path.expanduser("~/.cache/chatterbox-spd")
DEFAULT_OUTPUT_DIR = "/tmp"  # Directory for audio output files
MAX_TEXT_LENGTH = 65536
SOCKET_TIMEOUT = 300  # 5 minutes
DEFAULT_IDLE_TIMEOUT = 1200  # 20 minutes (0 to disable)
SD_LISTEN_FDS_START = 3  # First file descriptor for socket activation


class ChatterboxDaemon:
    def __init__(self, socket_path: str, device: str, voice_dir: str | None = None,
                 output_dir: str | None = None, idle_timeout: int = DEFAULT_IDLE_TIMEOUT):
        self.socket_path = socket_path
        self.device = device
        self.voice_dir = voice_dir or os.path.join(DEFAULT_CACHE_DIR, "voices")
        self.output_dir = output_dir or DEFAULT_OUTPUT_DIR
        self.idle_timeout = idle_timeout
        self.model = None
        self.server_socket = None
        self.running = False
        self.socket_activated = False
        self.last_activity = time.time()
        self.lock = threading.Lock()

        # Ensure directories exist
        os.makedirs(DEFAULT_CACHE_DIR, exist_ok=True)
        os.makedirs(self.voice_dir, exist_ok=True)
        os.makedirs(self.output_dir, exist_ok=True)

    def load_model(self):
        """Load the Chatterbox TTS model. Downloads on first use."""
        print(f"Loading Chatterbox TTS model on device: {self.device}", file=sys.stderr)
        print("(This may take a while on first run as models are downloaded)", file=sys.stderr)

        start_time = time.time()
        self.model = ChatterboxTurboTTS.from_pretrained(device=self.device)
        elapsed = time.time() - start_time

        print(f"Model loaded in {elapsed:.1f}s. Sample rate: {self.model.sr}", file=sys.stderr)

    def synthesize(self, text: str, voice: str | None = None,
                   exaggeration: float = 0.5, cfg_weight: float = 0.5) -> str:
        """
        Synthesize text to speech and return path to WAV file.

        Args:
            text: Text to synthesize
            voice: Optional voice name (corresponds to a .wav file in voice_dir)
            exaggeration: Exaggeration parameter (0.0-1.0)
            cfg_weight: CFG weight parameter (0.0-1.0)

        Returns:
            Path to generated WAV file
        """
        with self.lock:
            # Find voice reference file if specified
            audio_prompt_path = None
            if voice and voice != "default":
                voice_path = os.path.join(self.voice_dir, f"{voice}.wav")
                if os.path.exists(voice_path):
                    audio_prompt_path = voice_path
                else:
                    print(f"Warning: Voice '{voice}' not found at {voice_path}", file=sys.stderr)

            # Generate speech
            try:
                if audio_prompt_path:
                    wav = self.model.generate(
                        text,
                        audio_prompt_path=audio_prompt_path,
                        exaggeration=exaggeration,
                        cfg_weight=cfg_weight
                    )
                else:
                    wav = self.model.generate(
                        text,
                        exaggeration=exaggeration,
                        cfg_weight=cfg_weight
                    )
            except Exception as e:
                raise RuntimeError(f"Synthesis failed: {e}") from e

            # Save to temporary file in the output directory (shared with host)
            fd, output_path = tempfile.mkstemp(suffix=".wav", prefix="chatterbox_", dir=self.output_dir)
            os.close(fd)

            ta.save(output_path, wav, self.model.sr)

            return output_path

    def handle_client(self, client_socket: socket.socket):
        """Handle a client connection."""
        self.last_activity = time.time()
        try:
            client_socket.settimeout(SOCKET_TIMEOUT)

            # Read message length (4 bytes, big-endian)
            length_data = client_socket.recv(4)
            if len(length_data) < 4:
                return

            msg_length = struct.unpack(">I", length_data)[0]
            if msg_length > MAX_TEXT_LENGTH:
                response = {"error": "Message too long"}
                self._send_response(client_socket, response)
                return

            # Read the JSON message
            data = b""
            while len(data) < msg_length:
                chunk = client_socket.recv(min(4096, msg_length - len(data)))
                if not chunk:
                    break
                data += chunk

            if len(data) < msg_length:
                return

            # Parse request
            try:
                request = json.loads(data.decode("utf-8"))
            except json.JSONDecodeError as e:
                response = {"error": f"Invalid JSON: {e}"}
                self._send_response(client_socket, response)
                return

            # Handle different commands
            command = request.get("command", "synthesize")

            if command == "synthesize":
                text = request.get("text", "")
                if not text:
                    response = {"error": "No text provided"}
                else:
                    try:
                        output_path = self.synthesize(
                            text=text,
                            voice=request.get("voice"),
                            exaggeration=request.get("exaggeration", 0.5),
                            cfg_weight=request.get("cfg_weight", 0.5)
                        )
                        response = {"status": "ok", "audio_file": output_path, "sample_rate": self.model.sr}
                    except Exception as e:
                        response = {"error": str(e)}

            elif command == "ping":
                response = {"status": "ok", "message": "pong"}

            elif command == "list_voices":
                voices = ["default"]
                if os.path.isdir(self.voice_dir):
                    for f in os.listdir(self.voice_dir):
                        if f.endswith(".wav"):
                            voices.append(f[:-4])
                response = {"status": "ok", "voices": voices}

            elif command == "shutdown":
                response = {"status": "ok", "message": "shutting down"}
                self._send_response(client_socket, response)
                self.running = False
                return

            else:
                response = {"error": f"Unknown command: {command}"}

            self._send_response(client_socket, response)

        except TimeoutError:
            print("Client connection timed out", file=sys.stderr)
        except Exception as e:
            print(f"Error handling client: {e}", file=sys.stderr)
        finally:
            try:
                client_socket.close()
            except OSError:
                pass

    def _send_response(self, client_socket: socket.socket, response: dict):
        """Send a JSON response to the client."""
        data = json.dumps(response).encode("utf-8")
        length = struct.pack(">I", len(data))
        client_socket.sendall(length + data)

    def start(self):
        """Start the daemon."""
        # Load the model first (this takes time, do before accepting connections)
        self.load_model()

        # Check for systemd socket activation
        # Method 1: Check LISTEN_FDS environment variable (standard systemd way)
        # Method 2: Check if FD 3 is a valid socket (works with Podman containers)
        listen_fds = os.environ.get("LISTEN_FDS")
        listen_pid = os.environ.get("LISTEN_PID")

        socket_activated = False
        if listen_fds and listen_pid == str(os.getpid()):
            # Standard systemd socket activation
            num_fds = int(listen_fds)
            if num_fds >= 1:
                socket_activated = True
                print(f"Socket activation detected via LISTEN_FDS={num_fds}", file=sys.stderr)
        else:
            # Check if FD 3 is a socket (Podman passes socket but not env vars)
            try:
                # Try to get socket options - will fail if not a socket
                # Dup the FD first since socket.fromfd() creates a new FD internally
                test_fd = os.dup(SD_LISTEN_FDS_START)
                test_sock = socket.fromfd(test_fd, socket.AF_UNIX, socket.SOCK_STREAM)
                try:
                    test_sock.getsockopt(socket.SOL_SOCKET, socket.SO_TYPE)
                    socket_activated = True
                    print("Socket activation detected via FD 3 probe", file=sys.stderr)
                finally:
                    test_sock.close()
            except OSError:
                pass

        if socket_activated:
            # Duplicate the FD so Python doesn't close the original, then close the original
            inherited_fd = os.dup(SD_LISTEN_FDS_START)
            os.close(SD_LISTEN_FDS_START)
            self.server_socket = socket.fromfd(inherited_fd, socket.AF_UNIX, socket.SOCK_STREAM)
            self.socket_activated = True
            print("Using socket-activated file descriptor", file=sys.stderr)
        else:
            # Manual start - create our own socket
            if os.path.exists(self.socket_path):
                os.remove(self.socket_path)

            self.server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind(self.socket_path)
            self.server_socket.listen(5)

            # Make socket accessible
            os.chmod(self.socket_path, 0o666)
            print(f"Chatterbox TTS daemon listening on {self.socket_path}", file=sys.stderr)

        self.running = True
        self.last_activity = time.time()

        if self.idle_timeout > 0:
            print(f"Idle timeout: {self.idle_timeout} seconds", file=sys.stderr)

        # Handle connections
        while self.running:
            try:
                self.server_socket.settimeout(1.0)
                try:
                    client_socket, _ = self.server_socket.accept()
                    self.last_activity = time.time()
                    # Handle each client in a separate thread
                    thread = threading.Thread(target=self.handle_client, args=(client_socket,))
                    thread.daemon = True
                    thread.start()
                except TimeoutError:
                    # Check idle timeout
                    if self.idle_timeout > 0:
                        idle_time = time.time() - self.last_activity
                        if idle_time >= self.idle_timeout:
                            print(f"Idle timeout reached ({self.idle_timeout}s), exiting", file=sys.stderr)
                            break
                    continue
            except Exception as e:
                if self.running:
                    print(f"Error accepting connection: {e}", file=sys.stderr)

        self.cleanup()

    def cleanup(self):
        """Clean up resources."""
        if self.server_socket:
            try:
                self.server_socket.close()
            except OSError:
                pass

        # Only remove socket if we created it (not socket-activated)
        if not self.socket_activated and os.path.exists(self.socket_path):
            try:
                os.remove(self.socket_path)
            except OSError:
                pass

        print("Daemon stopped", file=sys.stderr)

    def stop(self):
        """Signal the daemon to stop."""
        self.running = False


def main():
    # Get defaults from environment variables
    env_idle_timeout = os.environ.get("CHATTERBOX_IDLE_TIMEOUT")
    default_idle_timeout = int(env_idle_timeout) if env_idle_timeout else DEFAULT_IDLE_TIMEOUT

    parser = argparse.ArgumentParser(
        description="Chatterbox TTS Daemon for Speech Dispatcher"
    )
    parser.add_argument(
        "--socket", "-s",
        default=DEFAULT_SOCKET_PATH,
        help=f"Path to Unix socket (default: {DEFAULT_SOCKET_PATH})"
    )
    parser.add_argument(
        "--device", "-d",
        default="cuda" if torch.cuda.is_available() else "cpu",
        choices=["cuda", "cpu"],
        help="Device to run model on (default: cuda if available, else cpu)"
    )
    parser.add_argument(
        "--voice-dir", "-v",
        default=None,
        help=f"Directory containing voice reference WAV files (default: {DEFAULT_CACHE_DIR}/voices)"
    )
    parser.add_argument(
        "--output-dir", "-o",
        default=os.environ.get("CHATTERBOX_OUTPUT_DIR", DEFAULT_OUTPUT_DIR),
        help=f"Directory for audio output files (default: {DEFAULT_OUTPUT_DIR}). "
             "Can also be set via CHATTERBOX_OUTPUT_DIR environment variable."
    )
    parser.add_argument(
        "--idle-timeout", "-t",
        type=int,
        default=default_idle_timeout,
        help=f"Idle timeout in seconds before daemon exits (0 to disable, default: {default_idle_timeout}). "
             "Can also be set via CHATTERBOX_IDLE_TIMEOUT environment variable."
    )

    args = parser.parse_args()

    daemon = ChatterboxDaemon(
        socket_path=args.socket,
        device=args.device,
        voice_dir=args.voice_dir,
        output_dir=args.output_dir,
        idle_timeout=args.idle_timeout
    )

    # Handle signals
    def signal_handler(signum, frame):
        print("\nReceived signal, shutting down...", file=sys.stderr)
        daemon.stop()

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Start the daemon
    daemon.start()


if __name__ == "__main__":
    main()
